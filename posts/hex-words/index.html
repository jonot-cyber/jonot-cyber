<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The longest word you can spell in hexadecimal | Jonot's Blog</title><meta name=keywords content="Linux"><meta name=description content="It&rsquo;s &ldquo;coldblooded&rdquo;
This is something that I did a while ago, so I thought I&rsquo;d just write a post about it. Here is a shell script to get every word that can be spelled with hexadecimal, sorted by length:
cat /usr/share/dict/words | tr &#34;[:upper:]&#34; &#34;[:lower:]&#34; | grep -E &#34;^[abcdeflzso]+$&#34; | tr &#34;lzso&#34; &#34;1250&#34; | awk '{print length, &#34;0x&#34; $0}' | sort -nr -k 1 | cut -d &#34; &#34; -f 2 If that seems incredibly cryptic to you, don&rsquo;t worry."><meta name=author content="Me"><link rel=canonical href=https://jonot.me/posts/hex-words/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jonot.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jonot.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jonot.me/favicon-32x32.png><link rel=apple-touch-icon href=https://jonot.me/apple-touch-icon.png><link rel=mask-icon href=https://jonot.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="The longest word you can spell in hexadecimal"><meta property="og:description" content="It&rsquo;s &ldquo;coldblooded&rdquo;
This is something that I did a while ago, so I thought I&rsquo;d just write a post about it. Here is a shell script to get every word that can be spelled with hexadecimal, sorted by length:
cat /usr/share/dict/words | tr &#34;[:upper:]&#34; &#34;[:lower:]&#34; | grep -E &#34;^[abcdeflzso]+$&#34; | tr &#34;lzso&#34; &#34;1250&#34; | awk '{print length, &#34;0x&#34; $0}' | sort -nr -k 1 | cut -d &#34; &#34; -f 2 If that seems incredibly cryptic to you, don&rsquo;t worry."><meta property="og:type" content="article"><meta property="og:url" content="https://jonot.me/posts/hex-words/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-16T09:08:41-05:00"><meta property="article:modified_time" content="2023-01-16T09:08:41-05:00"><meta property="og:site_name" content="Jonot's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="The longest word you can spell in hexadecimal"><meta name=twitter:description content="It&rsquo;s &ldquo;coldblooded&rdquo;
This is something that I did a while ago, so I thought I&rsquo;d just write a post about it. Here is a shell script to get every word that can be spelled with hexadecimal, sorted by length:
cat /usr/share/dict/words | tr &#34;[:upper:]&#34; &#34;[:lower:]&#34; | grep -E &#34;^[abcdeflzso]+$&#34; | tr &#34;lzso&#34; &#34;1250&#34; | awk '{print length, &#34;0x&#34; $0}' | sort -nr -k 1 | cut -d &#34; &#34; -f 2 If that seems incredibly cryptic to you, don&rsquo;t worry."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jonot.me/posts/"},{"@type":"ListItem","position":2,"name":"The longest word you can spell in hexadecimal","item":"https://jonot.me/posts/hex-words/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The longest word you can spell in hexadecimal","name":"The longest word you can spell in hexadecimal","description":"It\u0026rsquo;s \u0026ldquo;coldblooded\u0026rdquo;\nThis is something that I did a while ago, so I thought I\u0026rsquo;d just write a post about it. Here is a shell script to get every word that can be spelled with hexadecimal, sorted by length:\ncat /usr/share/dict/words | tr \u0026#34;[:upper:]\u0026#34; \u0026#34;[:lower:]\u0026#34; | grep -E \u0026#34;^[abcdeflzso]+$\u0026#34; | tr \u0026#34;lzso\u0026#34; \u0026#34;1250\u0026#34; | awk \u0026#39;{print length, \u0026#34;0x\u0026#34; $0}\u0026#39; | sort -nr -k 1 | cut -d \u0026#34; \u0026#34; -f 2 If that seems incredibly cryptic to you, don\u0026rsquo;t worry.","keywords":["Linux"],"articleBody":"It’s “coldblooded”\nThis is something that I did a while ago, so I thought I’d just write a post about it. Here is a shell script to get every word that can be spelled with hexadecimal, sorted by length:\ncat /usr/share/dict/words | tr \"[:upper:]\" \"[:lower:]\" | grep -E \"^[abcdeflzso]+$\" | tr \"lzso\" \"1250\" | awk '{print length, \"0x\" $0}' | sort -nr -k 1 | cut -d \" \" -f 2 If that seems incredibly cryptic to you, don’t worry. I’ll explain it all later.\nThe problem So what words can you spell with hexadecimal? Hexadecimal contains the numbers 0-9 and the letters a-f, so obviously you can use those. But I think you can use other letters. You can use 0 for o, 1 for l, and 2 and 5 for z and s. So in my mind, Anything that you can spell with the letters a, b, c, d, e, f, l, o, s, and z can be spelled with hexadecimal.\nBash You can think of each of the commands as programs that take in text streams and output text streams. The pipe, “|” takes the output from the last command and feeds it into the next command.\nThe thing is, all of this is running concurrently. That “tr” isn’t waiting for cat to finish. They both start running at the same time, and they are all processing input as they get it. This allows this script to run pretty fast.\nFor comparison, take this python program that I wrote to do the same process:\nimport re replacements = { \"l\": \"1\", \"o\": \"0\", \"s\": \"5\", \"z\": \"2\", } word_set = set() with open(\"/usr/share/dict/words\") as word_list: for word in word_list.readlines(): word = word[:-1].lower() if not re.search(r\"^[abcdeflzso]+$\", word): continue word_set.add(word) for word in sorted(word_set, key=lambda x: len(x), reverse=True): for find, replace in replacements.items(): word = word.replace(find, replace) print(f\"0x{word}\") This took 452 milliseconds to run.\nLet’s try Go, a faster, compiled language:\npackage main import ( \"bufio\" \"fmt\" \"os\" \"regexp\" \"sort\" \"strings\" ) func main() { var words []string re := regexp.MustCompile(\"^[abcdeflzso]+$\") f, err := os.Open(\"/usr/share/dict/words\") if err != nil { panic(err) } defer f.Close() scanner := bufio.NewScanner(f) scanner.Split(bufio.ScanLines) for scanner.Scan() { line := strings.ToLower(scanner.Text()) if !re.MatchString(line) { continue } words = append(words, line) } sort.Slice(words, func(i, j int) bool { return len(words[i]) \u003e len(words[j]) }) for _, word := range words { fmt.Printf(\"0x%s\\n\", word) } } Go only took 155 milliseconds to run. A major improvement! But what about with Bash?\nWell, that Bash one liner took only 28 milliseconds to run!\nThe program Here is the full program cleaned up:\ncat /usr/share/dict/words \\ | tr \"[:upper:]\" \"[:lower:]\" \\ | grep -E \"^[abcdeflzso]+$\" \\ | tr \"lzso\" \"1250\" \\ | awk '{print length, \"0x\" $0}' \\ | sort -nr -k 1 \\ | cut -d \" \" -f 2 cat /usr/share/dict/words cat is a very powerful program that is used to concatenate streams of text together. In this case, we are just using it to output the contents of a file. In this case, the file is /usr/share/dict/words\nIf you are on a Linux computer, you probably have this file. The file is simply a list of words, one per line. The file contains 479826 words long. Here is a sample of the text:\n... aboded abodement abodes aboding abody ... This file was originally created for spell checking, but it is useful for other purposes, like this one\ntr “[:upper:]” “[:lower:]” tr replaces characters in the input. If I used tr \"abc\" \"def\" it would take the input and replace all instances of the letter “a” with “d”, “b” with “e”, and “c” with “f”. In this case we are using a special case. Using tr \"[:upper:]\" \"[:lower:]\" Will transform all uppercase letters to lowercase ones. So what this line does is makes sure that all of our letters are lowercase.\ngrep -E “^[abcdeflzso]+$” grep does regexes. The name grep stands for “(g)lobally search for a (r)egular (e)xpression and (p)rint matching lines”\nIf you don’t know what a regex is, then I will explain that string for you. “^” tells grep that the match needs to start at the beginning of the line, and “$” tells it that it needs to end at the end of the line. Basically what that does is it says that it can’t just find what we’re looking for in part of a line, it has to be the full line.\nBrackets match a character that is any of the letters inside. So that part will match any of the letters mentioned above that could be represented in hexadecimal.\nAnd the plus says that you are looking for one or more of what came before.\nAs a whole, the regex is looking for a line that consists of one or more of the following characters, and nothing else:\na b c d e f l z s o (Sorry if that explanation didn’t really make sense. Regex is hard, and I’m not the best at explaining things)\nThe last thing I want to talk about is “-E” which enables extended regex. As it turns out, ^, $, and [ ] aren’t supported in normal regex. To get those features, I need to enable extended regex.\ntr “lzso” “1250” We are back to tr, which I have already explained. What this line does is replaces the letter “l” with “1”, “z” with “2”, and so on.\nI don’t feel like I need to explain this one in detail, since I already explained tr.\nawk ‘{print length, “0x” $0}’ This one will probably be hard to explain because AWK is it’s own programming language. But to explain, the thing in braces is getting run for every line. A major feature of AWK is specifying a regex to say which lines to run for, but we already know that we are matching every line, so we don’t need that.\nThis is just a print statement. In python, this would be print(len(s), f\"0x{s}\"). The length variable contains the length of the current line. Since there is a comma there, it will put that in a different column, or basically just add a space between that and the next one. $0 is a variable that stores the complete line. We are combining that with “0x” because that is how you represent hex values in most programming languages. Maybe an example will help you understand.\nIf AWK got the input:\n... defaced deface5 defade defa1c0 ... It would output:\n... 7 0xdefaced 7 0xdeface5 6 0xdefade 7 0xdefa1c0 ... sort -nr -k 1 sort is pretty self explanatory. It sorts the input. But we did pass in some flags, so I should explain those\nFirst of all, -k 1. This is telling it to sort by the first column, which is that length that we added with AWK.\n-n means that sort should sort numerically instead of alphabetically.\n-r makes the sort in reverse order, so it sorts from longest to shortest instead of shortest to longest\ncut -d \" \" -f 2 We are using cut to remove the length that we added with AWK, since we don’t need it anymore and it looks pretty ugly.\n-d \" \" tells cut that the columns are separated with spaces, and -f 2 tells it that we only want to include the second field, or column.\nOutput After this, we will get a list of words that can be spelled in hexadecimal, spelled in hexadecimal. If you’ve also done this, you will notice that I lied at the top of the article. It’s not just “coldblooded”, there are two other words that tie it: Salsolaceae and Basellaceae. Both of these are words for families of plants that most people are not familiar with, so I didn’t think that it would be as interesting to mention.\nSo what is the takeaway from this? Well, one should be that playing with shell scripts is fun. But other than that, you should take something away about how powerful and fast shell scripts are for text processing.\nDoes this mean that you should start writing all of your programs in bash? Of course not, that would be a horrible idea. What I do think is a valuable takeaway, however, is how processing things in parallel can get you a lot of speed. One could probably get that Go implementation to be a lot faster by using goroutines to essentially replicate what Bash was doing, but in a compiled language. But overall, I think that the best takeaway is just that shell scripts are cool.\n","wordCount":"1430","inLanguage":"en","datePublished":"2023-01-16T09:08:41-05:00","dateModified":"2023-01-16T09:08:41-05:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jonot.me/posts/hex-words/"},"publisher":{"@type":"Organization","name":"Jonot's Blog","logo":{"@type":"ImageObject","url":"https://jonot.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jonot.me/ accesskey=h title="Jonot's Blog (Alt + H)">Jonot's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The longest word you can spell in hexadecimal</h1><div class=post-meta><span title='2023-01-16 09:08:41 -0500 -0500'>2023-01-16</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</div></header><div class=post-content><p>It&rsquo;s &ldquo;coldblooded&rdquo;</p><p>This is something that I did a while ago, so I thought I&rsquo;d just write a post about it. Here is a shell script to get every word that can be spelled with hexadecimal, sorted by length:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /usr/share/dict/words | tr <span style=color:#e6db74>&#34;[:upper:]&#34;</span> <span style=color:#e6db74>&#34;[:lower:]&#34;</span> | grep -E <span style=color:#e6db74>&#34;^[abcdeflzso]+</span>$<span style=color:#e6db74>&#34;</span> | tr <span style=color:#e6db74>&#34;lzso&#34;</span> <span style=color:#e6db74>&#34;1250&#34;</span> | awk <span style=color:#e6db74>&#39;{print length, &#34;0x&#34; $0}&#39;</span> | sort -nr -k <span style=color:#ae81ff>1</span> | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>If that seems incredibly cryptic to you, don&rsquo;t worry. I&rsquo;ll explain it all later.</p><h2 id=the-problem>The problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>So what words can you spell with hexadecimal? Hexadecimal contains the numbers 0-9 and the letters a-f, so obviously you can use those. But I think you can use other letters. You can use 0 for o, 1 for l, and 2 and 5 for z and s. So in my mind, Anything that you can spell with the letters a, b, c, d, e, f, l, o, s, and z can be spelled with hexadecimal.</p><h2 id=bash>Bash<a hidden class=anchor aria-hidden=true href=#bash>#</a></h2><p>You can think of each of the commands as programs that take in text streams and output text streams. The pipe, &ldquo;|&rdquo; takes the output from the last command and feeds it into the next command.</p><p>The thing is, all of this is running concurrently. That &ldquo;tr&rdquo; isn&rsquo;t waiting for cat to finish. They both start running at the same time, and they are all processing input as they get it. This allows this script to run pretty fast.</p><p>For comparison, take this python program that I wrote to do the same process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>replacements <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;l&#34;</span>: <span style=color:#e6db74>&#34;1&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;o&#34;</span>: <span style=color:#e6db74>&#34;0&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;s&#34;</span>: <span style=color:#e6db74>&#34;5&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;z&#34;</span>: <span style=color:#e6db74>&#34;2&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>word_set <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/usr/share/dict/words&#34;</span>) <span style=color:#66d9ef>as</span> word_list:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> word_list<span style=color:#f92672>.</span>readlines():
</span></span><span style=display:flex><span>		word <span style=color:#f92672>=</span> word[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>lower()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> re<span style=color:#f92672>.</span>search(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;^[abcdeflzso]+$&#34;</span>, word):
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		word_set<span style=color:#f92672>.</span>add(word)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> sorted(word_set, key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: len(x), reverse<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> find, replace <span style=color:#f92672>in</span> replacements<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>		word <span style=color:#f92672>=</span> word<span style=color:#f92672>.</span>replace(find, replace)
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;0x</span><span style=color:#e6db74>{</span>word<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>This took 452 milliseconds to run.</p><p>Let&rsquo;s try Go, a faster, compiled language:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;regexp&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>re</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>regexp</span>.<span style=color:#a6e22e>MustCompile</span>(<span style=color:#e6db74>&#34;^[abcdeflzso]+$&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;/usr/share/dict/words&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>f</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>ScanLines</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Scan</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>line</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Text</span>())
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>re</span>.<span style=color:#a6e22e>MatchString</span>(<span style=color:#a6e22e>line</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>words</span> = append(<span style=color:#a6e22e>words</span>, <span style=color:#a6e22e>line</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>words</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>words</span>[<span style=color:#a6e22e>i</span>]) &gt; len(<span style=color:#a6e22e>words</span>[<span style=color:#a6e22e>j</span>])
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>word</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>words</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;0x%s\n&#34;</span>, <span style=color:#a6e22e>word</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go only took 155 milliseconds to run. A major improvement! But what about with Bash?</p><p>Well, that Bash one liner took only <strong>28 milliseconds</strong> to run!</p><h2 id=the-program>The program<a hidden class=anchor aria-hidden=true href=#the-program>#</a></h2><p>Here is the full program cleaned up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /usr/share/dict/words <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| tr <span style=color:#e6db74>&#34;[:upper:]&#34;</span> <span style=color:#e6db74>&#34;[:lower:]&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| grep -E <span style=color:#e6db74>&#34;^[abcdeflzso]+</span>$<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| tr <span style=color:#e6db74>&#34;lzso&#34;</span> <span style=color:#e6db74>&#34;1250&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| awk <span style=color:#e6db74>&#39;{print length, &#34;0x&#34; $0}&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| sort -nr -k <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| cut -d <span style=color:#e6db74>&#34; &#34;</span> -f <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><h3 id=cat-usrsharedictwords>cat /usr/share/dict/words<a hidden class=anchor aria-hidden=true href=#cat-usrsharedictwords>#</a></h3><p><a href=https://www.man7.org/linux/man-pages/man1/cat.1.html>cat</a> is a very powerful program that is used to concatenate streams of text together. In this case, we are just using it to output the contents of a file. In this case, the file is <code>/usr/share/dict/words</code></p><p>If you are on a Linux computer, you probably have this file. The file is simply a list of words, one per line. The file contains 479826 words long. Here is a sample of the text:</p><pre tabindex=0><code>...
aboded
abodement
abodes
aboding
abody
...
</code></pre><p>This file was originally created for spell checking, but it is useful for other purposes, like this one</p><h3 id=tr-upper-lower>tr &ldquo;[:upper:]&rdquo; &ldquo;[:lower:]&rdquo;<a hidden class=anchor aria-hidden=true href=#tr-upper-lower>#</a></h3><p><a href=https://man7.org/linux/man-pages/man1/tr.1.html>tr</a> replaces characters in the input. If I used <code>tr "abc" "def"</code> it would take the input and replace all instances of the letter &ldquo;a&rdquo; with &ldquo;d&rdquo;, &ldquo;b&rdquo; with &ldquo;e&rdquo;, and &ldquo;c&rdquo; with &ldquo;f&rdquo;. In this case we are using a special case. Using <code>tr "[:upper:]" "[:lower:]"</code> Will transform all uppercase letters to lowercase ones. So what this line does is makes sure that all of our letters are lowercase.</p><h3 id=grep--e-abcdeflzso>grep -E &ldquo;^[abcdeflzso]+$&rdquo;<a hidden class=anchor aria-hidden=true href=#grep--e-abcdeflzso>#</a></h3><p><a href=https://man7.org/linux/man-pages/man1/grep.1.html>grep</a> does regexes. The name grep stands for &ldquo;(g)lobally search for a (r)egular (e)xpression and (p)rint matching lines&rdquo;</p><p>If you don&rsquo;t know what a regex is, then I will explain that string for you. &ldquo;^&rdquo; tells grep that the match needs to start at the beginning of the line, and &ldquo;$&rdquo; tells it that it needs to end at the end of the line. Basically what that does is it says that it can&rsquo;t just find what we&rsquo;re looking for in part of a line, it has to be the full line.</p><p>Brackets match a character that is any of the letters inside. So that part will match any of the letters mentioned above that could be represented in hexadecimal.</p><p>And the plus says that you are looking for one or more of what came before.</p><p>As a whole, the regex is looking for a line that consists of one or more of the following characters, and nothing else:</p><ul><li>a</li><li>b</li><li>c</li><li>d</li><li>e</li><li>f</li><li>l</li><li>z</li><li>s</li><li>o</li></ul><p>(Sorry if that explanation didn&rsquo;t really make sense. Regex is hard, and I&rsquo;m not the best at explaining things)</p><p>The last thing I want to talk about is &ldquo;-E&rdquo; which enables extended regex. As it turns out, ^, $, and [ ] aren&rsquo;t supported in normal regex. To get those features, I need to enable extended regex.</p><h3 id=tr-lzso-1250>tr &ldquo;lzso&rdquo; &ldquo;1250&rdquo;<a hidden class=anchor aria-hidden=true href=#tr-lzso-1250>#</a></h3><p>We are back to tr, which I have already explained. What this line does is replaces the letter &ldquo;l&rdquo; with &ldquo;1&rdquo;, &ldquo;z&rdquo; with &ldquo;2&rdquo;, and so on.</p><p>I don&rsquo;t feel like I need to explain this one in detail, since I already explained tr.</p><h3 id=awk-print-length-0x-0>awk &lsquo;{print length, &ldquo;0x&rdquo; $0}&rsquo;<a hidden class=anchor aria-hidden=true href=#awk-print-length-0x-0>#</a></h3><p>This one will probably be hard to explain because <a href=https://man7.org/linux/man-pages/man1/awk.1p.html>AWK</a> is it&rsquo;s own programming language. But to explain, the thing in braces is getting run for every line. A major feature of AWK is specifying a regex to say which lines to run for, but we already know that we are matching every line, so we don&rsquo;t need that.</p><p>This is just a print statement. In python, this would be <code>print(len(s), f"0x{s}")</code>. The length variable contains the length of the current line. Since there is a comma there, it will put that in a different column, or basically just add a space between that and the next one. $0 is a variable that stores the complete line. We are combining that with &ldquo;0x&rdquo; because that is how you represent hex values in most programming languages. Maybe an example will help you understand.</p><p>If AWK got the input:</p><pre tabindex=0><code>...
defaced
deface5
defade
defa1c0
...
</code></pre><p>It would output:</p><pre tabindex=0><code>...
7 0xdefaced
7 0xdeface5
6 0xdefade
7 0xdefa1c0
...
</code></pre><h3 id=sort--nr--k-1>sort -nr -k 1<a hidden class=anchor aria-hidden=true href=#sort--nr--k-1>#</a></h3><p><a href=https://man7.org/linux/man-pages/man1/sort.1.html>sort</a> is pretty self explanatory. It sorts the input. But we did pass in some flags, so I should explain those</p><p>First of all, -k 1. This is telling it to sort by the first column, which is that length that we added with AWK.</p><p>-n means that sort should sort numerically instead of alphabetically.</p><p>-r makes the sort in reverse order, so it sorts from longest to shortest instead of shortest to longest</p><h3 id=cut--d----f-2>cut -d " " -f 2<a hidden class=anchor aria-hidden=true href=#cut--d----f-2>#</a></h3><p>We are using <a href=https://man7.org/linux/man-pages/man1/cut.1.html>cut</a> to remove the length that we added with AWK, since we don&rsquo;t need it anymore and it looks pretty ugly.</p><p>-d " " tells cut that the columns are separated with spaces, and -f 2 tells it that we only want to include the second field, or column.</p><h2 id=output>Output<a hidden class=anchor aria-hidden=true href=#output>#</a></h2><p>After this, we will get a list of words that can be spelled in hexadecimal, spelled in hexadecimal. If you&rsquo;ve also done this, you will notice that I lied at the top of the article. It&rsquo;s not just &ldquo;coldblooded&rdquo;, there are two other words that tie it: Salsolaceae and Basellaceae. Both of these are words for families of plants that most people are not familiar with, so I didn&rsquo;t think that it would be as interesting to mention.</p><p>So what is the takeaway from this? Well, one should be that playing with shell scripts is fun. But other than that, you should take something away about how powerful and fast shell scripts are for text processing.</p><p>Does this mean that you should start writing all of your programs in bash? Of course not, that would be a horrible idea. What I do think is a valuable takeaway, however, is how processing things in parallel can get you a lot of speed. One could probably get that Go implementation to be a lot faster by using goroutines to essentially replicate what Bash was doing, but in a compiled language. But overall, I think that the best takeaway is just that shell scripts are cool.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jonot.me/tags/linux/>Linux</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jonot.me/>Jonot's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>